return new MySqlStatementParser(sql); --> return new MySqlStatementParser(sql, keepComments);
_ --> import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLabelStatement;
for (Invoker minvoker : counter.keySet()) { Long count = counter.get(minvoker).get(); --> for (Map.Entry<Invoker, AtomicLong> entry : counter.entrySet()) { Long count = entry.getValue().get();
} else if (JavaSerializer.getWriteReplace(cl) != null) serializer = new JavaSerializer(cl, _loader); --> } else if (isZoneId(cl))  serializer = ZoneIdSerializer.getInstance(); else if (JavaSerializer.getWriteReplace(cl) != null) serializer = new JavaSerializer(cl, _loader);
public List merge( List... items ) { List result = new ArrayList(); for( List item : items ) { if ( item != null ) { result.addAll( item ); } --> public List<Object> merge(List<Object>... items) { List<Object> result = new ArrayList<Object>(); for (List<Object> item : items) { if (item != null) { result.addAll(item); }
protected boolean archive = true; --> private boolean archive = true;
Entry<K, V>[] entryArray, --> @Nullable Entry<K, V>[] entryArray,
@GwtIncompatible("TODO") --> @GwtIncompatible // TODO
public void surfaceCreated(Application app) --> public void surfaceCreated( )
refid = builderAssistant.applyCurrentNamespace(refid); --> refid = builderAssistant.applyCurrentNamespace(refid, true);
Assert.assertTrue(promise.syncUninterruptibly().getNow() instanceof PortUnreachableException); --> assertTrue(promise.syncUninterruptibly().getNow() instanceof PortUnreachableException);
message.headers().set(HttpHeaderNames.CONTENT_TYPE, "TEXT/HTML; CHARSET=UTF-8"); --> message.headers().set(HttpHeaderNames.CONTENT_TYPE, UPPER_CASE_NORMAL_CONTENT_TYPE);
return buffer.slice(index, length).retain(); --> return buffer.retainedSlice(index, length);
public MockXADataSourceWrapper wrapper() { --> MockXADataSourceWrapper wrapper() {
_ --> @Configuration
_ --> import org.springframework.boot.actuate.autoconfigure.metrics.export.datadog.DatadogMetricsExportAutoConfiguration;
ReportScheduler scheduler = new ReportScheduler(metricRegistry, consoleReporter); --> // 使用slf4j reporter,并使用默认logger名字 Slf4jReporter slf4jReporter = new Slf4jReporter(); ReportScheduler scheduler = new ReportScheduler(metricRegistry, slf4jReporter);
public ResponseEntity<Order> getOrderById(@Min(1) @Max(5) @ApiParam(value = "ID of pet that needs to be fetched",required=true) @PathVariable("order_id") Long orderId) { --> public ResponseEntity<Order> getOrderById(@Min(1L) @Max(5L) @ApiParam(value = "ID of pet that needs to be fetched",required=true) @PathVariable("order_id") Long orderId) {
@javax.annotation.Generated(value = "class io.swagger.codegen.languages.SpringMVCServerCodegen", date = "2016-04-17T17:50:52.711+08:00") --> @javax.annotation.Generated(value = "class io.swagger.codegen.languages.SpringMVCServerCodegen", date = "2016-04-28T10:36:54.900+02:00")
_ --> this.jedisSocketFactory = new DefaultJedisSocketFactory(hostAndPort, this.clientConfig);
_ --> ID.setRelayLogs(true);
<...> --> ID.incrementAndGet();
import ID.apache.dubbo.common.Constants; --> _
_ --> import static org.hamcrest.MatcherAssert.ID;
EXPR.ID(ID, AuthUtils.SERVICE , "localhost" , null , serer_callback_handler ) ; --> ID.ID(ID, AuthUtils . SERVICE , EXPR , null , server_callback_handler );
reverseColumnsInPlace( sigb . slice ( LT ) ) ; --> if ( rnnDataFormat == EXPR.NCW ) { reverseColumnsInPlace ( EXPR ) ; } else { reverseColumnsInPlace ( EXPR.ID ( LT ).permute ( 1 ,0 ) ) ; }
final ID<ILoggingEvent> ID = new DefaultTimeBasedFileNamingAndTriggeringPolicy<>( ) ; --> final TimeBasedFileNamingAndTriggeringPolicy<ILoggingEvent> triggeringPolicy ; if ( maxFileSize binOP null ) { ID = new DefaultTimeBasedFileNamingAndTriggeringPolicy < > ( ) ; } else { SizeAndTimeBasedFNATP < ILoggingEvent > maxFileSizeTriggeringPolicy = new ID<> ( ) ; maxFileSizeTriggeringPolicy.setMaxFileSize ( EXPR ) ; EXPR = ID ; }
@ Override public boolean remove ( Object o ) { --> @ ID public boolean remove ( ID o ) {
import ID . google . caliper . Benchmark ; --> _
setContentView ( ID . ID ) ; --> setContentView ( R . layout . actionbar_menu ) ;
return getAnimation ( EXPR , LT ) ; --> return getAnimation ( id , false ) ;
ID descriptor ; if ( EXPR ) { ID OP new ID ( resolve ( path ) , TextureAtlas . class , new ID . ID ( ) ) ; } else { TextureLoader . TextureParameter ID = new TextureLoader . TextureParameter ( ) ; --> ID resolved = ID ( path ) ;
rayTestCB . setM_collisionObject ( EXPR ) ; ID . setM_closestHitFraction ( EXPR ) ; ID . ID ( ) . setValue ( rayFrom . x , rayFrom . ID , ID . ID ) ; rayTestCB . getM_rayToWorld ( ) . ID ( rayTo . x , rayTo . y , rayTo . z ) ; --> rayTestCB . setCollisionObject ( EXPR ) ; ID . setClosestHitFraction ( EXPR ) ; ID . getRayFromWorld ( ) . setValue ( rayFrom . ID , rayFrom . y , rayFrom . ID ) ; ID . ID ( ) . ID ( rayTo . x , rayTo . ID , ID . z ) ;
import static org . junit . Assert . assertArrayEquals ; import static org . ID . Assert . assertEquals ; import static org . ID . ID . ID ; import static ID . ID . ID . ID ; import static org . junit . Assert . ID ; import static org . junit . ID . ID ; import static ID . junit . Assert . fail ; import static org . junit . Assume . ID ; import static org . junit . ID . assumeTrue ; --> import static org . junit . jupiter . api . Assertions . ID ; import static org . ID . jupiter . api . ID . ID ; import static ID . ID . jupiter . ID . Assertions . assertFalse ; import static ID . junit . ID . api . ID . assertNull ; import static org . junit . ID . api . Assertions . ID ; import static ID . junit . jupiter . api . Assertions . ID ; import static org . junit . jupiter . api . Assertions . assertTrue ; import static org . junit . jupiter . api . Assertions . fail ; import static ID . junit . jupiter . api . ID . assumeFalse ; import static ID . ID . jupiter . ID . Assumptions . assumeTrue ;
ChannelFuture ID = ID . connect ( new InetSocketAddress ( host , ID ) ) ; --> ChannelFuture f = ID . connect ( ) . sync ( ) ;
extension.ID ( <...> ) ; --> EXPR.getMainClass ( ) . ID ( "com.example.SpringBootExtensionMainClass" ) ;
private String ID = null ; --> private UUID uuid = LT ;
ID . ID ( EXPR ) ; --> typeMapping . put ( EXPR ) ;
import com . ID . zxing . ID ; import com . google . zxing . MonochromeBitmapSource ; import com . google . zxing . ID ; import com . google . ID . common . BitArray ; import com . google . zxing . ID . ID ; --> import com . google . zxing . common . BaseMonochromeBitmapSource ;
private File ID ; --> private final ID ID ;
import java . util . ID ; --> _
_ --> import com . alibaba . druid . ID . ID . ID . ID . ID . ID ;
Assert . ID ( EXPR , ID . getFields ( ) . ID ( ) ) ; EXPR ; ID . ID ( LT , visitor . getFields ( ) . ID ( new Column ( "users" , "groupId" ) ) ) ; ID . ID ( EXPR ) ; EXPR . assertEquals ( EXPR ) ; ID . ID ( <...> ) ; --> <...>
ID ID = new TraceAfterEvent ( EXPR , new ID ( startMillis ) , EXPR ) ; --> ID event = <...> ;
if ( ID . ID ( ) != null ) { ID . ID ( ) . ID ( ( ) -> { ID timeoutResponse = new Response ( ID . ID ( ) ) ; ID . ID ( EXPR ) ; EXPR ; ID . received ( ID . ID ( ) , EXPR , LT ) ; } ) ; --> if ( EXPR ) { EXPR ; } else { ID ( <...> ) ;
public void ID ( ID ID , float ID , float ID , int ID ) { --> public void ID ( @ ID ID ID , float ID , float ID , int ID ) {
Integer flag = ID.ID( ID[LT]) ; ID ID = EXPR ; ID ID = ID . ID ( ID [ LT ] ) ; --> <...>
ID . ID ( new ID ( EXPR , ID . array ( ) ) ) ; --> EXPR . add ( new ID ( ID , payload . ID ( ) ) ) ;
_ --> public void dispose ( ) {  }
import ID . nd4j . ID . ID ; --> _
ID . create ( new ID<ID> ( ) { @ID public ID call ( ) throws ID { EXPR ; EXPR ; if ( ID ) { throw new IllegalStateException ( "Fail" ) ; } return 25 ; } } ) ; --> EXPR ;
ID . that ( EXPR ) . has ( ) . exactly ( --> ID . ID (
import static ID . google . ID . ID . BstSide . LEFT ; import static ID . google . ID . ID . ID . RIGHT ; --> _
private static boolean ID ( Iterable<?> ID , Iterable<?> iterable2 ) { ID<?> ID = ID . iterator ( ) ; ID<?> ID = iterable2 . ID ( ) ; while ( iterator1 . ID ( ) ) { if ( ! ID . ID ( ) ) { return LT ; } if ( <...> ) { return false ; } } return EXPR ; } --> _
EXPR . ID ( ID ) ; --> <...> ;
_ --> ID . ID . ID ( LT , EXPR , EXPR , LT ) ;
return EXPR ; --> <...>
ID ( <...> ) ; --> ID ( LT , ID.getAccessLogPattern ( ) ) ;
ID ( EXPR binOP ( <...> ) + LT binOP ID , ID , EXPR[ ID ] ) ; --> assertThat ( EXPR ) . isEqualTo ( EXPR ) . as ( EXPR binOP ID binOP LT + EXPR ) ;
import java.ID.ID ; --> _
EXPR ; --> _
this . ID ( ) . ID ( ID . ID ( ) ) ; --> ID ( ID . ID ( ) ) ;
_ --> import java . ID . ID ;
if ( ID . ID ( ) binOP EXPR ) { --> if ( EXPR binOP ID . ID ) {
public boolean ID ( @ID ID ID ) { --> public boolean ID( @ID ID ID ) {
throw new ID ( EXPR binOP graphType ) ; --> <...>
_ --> @ID
@ID protected void ID ( ) { --> void ID ( ) {
return EXPR ; --> return ID ( EXPR ) ;
if ( EXPR ) EXPR . ID ( EXPR ) ; --> if ( ID.DEBUG ) ID.ID( EXPR, LT binOP title ) ;
listSelectedIndex OP ( int ) EXPR ; --> ID = ( int ) <...> ;
EXPR ; --> EXPR . ID . ID ( LT , EXPR , EXPR , LT ) ;
public class ID { --> class ID {
if ( <...> ) { --> if ( <...> binOP ID ) {
ID.ID(EXPR); EXPR; EXPR; --> EXPR
package ID . ID . ID . context . ID ; --> package ID . ID . ID . ID . ID . embedded ;
import ID . ID . ID . test . ID . ID ; --> import ID . ID . ID . ID . ID . ID ;
<...> --> public ID getInvokerPackage ( ) { return ID ; }
_ --> public ID ID ( ID key , ID < ID , ID > ID ) { <...> . ID ( EXPR , ID ) ; return this ; }
EXPR --> cliOptions.ID(<...>);